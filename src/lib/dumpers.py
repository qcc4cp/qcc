# python3
# pylint: disable=invalid-name

"""Various output formats for the compiler IR."""

from typing import List

from src.lib import helper


def reg2str(ir, idx):
  """Convert absolute register index to register-based string."""

  for r in ir.regs:
    if r[0] == idx:
      return f'{r[1]}[{r[2]}]'
  return '???'


def qasm(ir) -> str:
  """Dump IR in qasm format."""

  res = 'OPENQASM 2.0;\n'
  for regs in ir.regset:
    res += f'qreg {regs[0]}[{regs[1]}];\n'
  res += '\n'

  for op in ir.gates:
    if op.is_gate():
      res += op.name
      if op.val is not None:
        res += '({})'.format(helper.pi_fractions(op.val))
      if op.is_single():
        res += f' {reg2str(ir, op.idx0)};\n'
      if op.is_ctl():
        res += f' {reg2str(ir, op.ctl)},{reg2str(ir, op.idx1)};\n'
  return res


def libq(ir) -> str:
  """Dump IR to a compilable C++ program with libq."""

  res = (
      '// This file was generated by qc.dump_to_file()\n\n'
      + '#include <math.h>\n'
      + '#include <stdio.h>\n\n'
      + '#include "libq.h"\n\n'
      + 'int main(int argc, char* argv[]) {\n\n'
  )

  total_regs = 0
  for regs in ir.regset:
    total_regs += regs[1]
  res += f'  libq::qureg* q = libq::new_qureg(0, {total_regs});\n\n'

  total_regs = 0
  for regs in ir.regset:
    for r in regs[2].val:
      if r == 1:
        res += f'  libq::x({total_regs}, q);\n'
      total_regs += 1
  res += '\n'

  for op in ir.gates:

    if op.is_gate():
      res += f'  libq::{op.name}('

      if op.is_single():
        res += f'{op.idx0}'
        if op.val is not None:
          res += ', {}'.format(helper.pi_fractions(op.val, 'M_PI'))
        res += ', q);\n'

      if op.is_ctl():
        res += f'{op.ctl}, {op.idx1}'
        if op.val is not None:
          res += ', {}'.format(helper.pi_fractions(op.val, 'M_PI'))
        res += ', q);\n'

  res += '\n  libq::flush(q);\n'
  res += '  libq::print_qureg(q);\n'
  res += '  libq::delete_qureg(q);\n'
  res += '  return EXIT_SUCCESS;\n'
  res += '}\n'
  return res


def cirq(ir) -> str:
  """Dump IR to a Cirq Python file."""

  res = (
      '# This file was generated by qc.dump_to_file()\n\n'
      + 'import cirq\n'
      + 'import cmath\n'
      + 'from cmath import pi\n'
      + 'import numpy as np\n\n'
  )

  res += 'qc = cirq.Circuit()\n\n'
  res += f'r = cirq.LineQubit.range({ir.nregs})\n'
  res += '\n'

  op_map = {'h': 'H', 'x': 'X', 'y': 'Y', 'z': 'Z', 'cx': 'CX', 'cz': 'CZ'}

  for op in ir.gates:
    if op.is_gate():
      if op.name == 'u1':
        res += 'm = np.array([(1.0, 0.0), (0.0, '
        res += f'cmath.exp(1j * {helper.pi_fractions(op.val)}))])\n'
        res += f'qc.append(cirq.MatrixGate(m).on(r[{op.idx0}]))\n'
        continue

      if op.name == 'cu1':
        res += 'm = np.array([(1.0, 0.0), (0.0, '
        res += f'cmath.exp(1j * {helper.pi_fractions(op.val)}))])\n'
        res += (
            'qc.append(cirq.MatrixGate(m).controlled()'
            + f'(r[{op.idx0}], r[{op.idx1}]))\n'
        )
        continue

      if op.name == 'cv':
        res += 'm = np.array([(1+1j, 1-1j), (1-1j, 1+1j)]) * 0.5\n'
        res += (
            'qc.append(cirq.MatrixGate(m).controlled()'
            + f'(r[{op.idx0}], r[{op.idx1}]))\n'
        )
        continue

      if op.name == 'cv_adj':
        res += 'm = np.array([(1+1j, 1-1j), (1-1j, 1+1j)]) * 0.5\n'
        res += (
            'qc.append(cirq.MatrixGate('
            + 'np.conj(m.transpose())).controlled()'
            + f'(r[{op.idx0}], r[{op.idx1}]))\n'
        )
        continue

      op_name = op_map[op.name]
      res += f'qc.append(cirq.{op_name}('

      if op.is_single():
        res += f'r[{op.idx0}]'
        if op.val is not None:
          res += ', {}'.format(helper.pi_fractions(op.val))
        res += '))\n'

      if op.is_ctl():
        res += f'r[{op.ctl}], r[{op.idx1}]'
        if op.val is not None:
          res += ', {}'.format(helper.pi_fractions(op.val))
        res += '))\n'

  res += 'sim = cirq.Simulator()\n'
  res += "print('Simulate...')\n"
  res += 'result = sim.simulate(qc)\n'
  res += 'res_str = str(result)\n'
  res += "print(res_str.encode('utf-8'))\n"

  return res


def latex(ir) -> str:
  """Minimal Dumper to quantikz Latex Format."""

  carr: List[List[str]] = []

  def new_col():
    col = [r'\qw&'] * ir.nregs
    carr.append(col)
    gcol = [False] * ir.nregs
    return col, gcol

  def fix(s):
    s = s.replace('ry', 'Y_')
    s = s.replace('rz', 'Z_')
    s = s.replace('gate{cx', 'targ{')
    s = s.replace('_adj', r'^\dagger')
    s = s.replace(r'^T', r'^\dagger')
    return s

  def need_new_col(idx, gates, gcol):
    if not idx:
      return True
    if not gates[idx - 1].is_single():
      return True
    if not gates[idx].is_single():
      return True
    if ir.gates[idx].idx0 != gates[idx-1].idx0:
      if not gcol[ir.gates[idx].idx0]:
        return False
    return True

  col, gcol = new_col()

  for idx, op in enumerate(ir.gates):
    if op.is_section():
      col[0] = r'\qw\slice{' + op.name + '}&'
      continue
    if not op.is_gate():
      continue
    if need_new_col(idx, ir.gates, gcol):
      col, gcol = new_col()

    name = op.name.upper()
    #if op.name == 'cu1' or op.name == 'u1':
    #  name = ''

    parm = ''
    if op.val is not None:
      parm = '{}'.format(helper.pi_fractions(op.val, r'\pi'))

    if op.is_single():
      col[op.idx0] = (r'\gate{' + f'{name}' + parm + '}&')
      col[op.idx0] = fix(col[op.idx0])
      gcol[op.idx0] = True

    if op.is_ctl():
      col[op.ctl] = (r'\ctrl{' +
                     '{}{}&'.format(op.idx1 - op.ctl, '}'))
      col[op.idx1] = (r'\gate{' +
                      '{}{}&'.format(name + parm, '}'))
      col[op.ctl] = fix(col[op.ctl])
      col[op.idx1] = fix(col[op.idx1])

  res = r'\begin{qcc}[column sep=0.12cm]' + '\n'
  for q in range(ir.nregs):
    for col in carr:
      res += col[q]
    res += r'\qw\\' + '\n'
  if q == ir.nregs - 1:
    res = res[:-3] + '\n'
  res += r'\end{qcc}'
  return res


def totext(ir) -> str:
  """Minimal Dumper to ASCII text."""

  def mkname(op):
    name = op.name.upper()
    if name == 'CZ':
      name = 'o'
    if op.val is not None:
      parm = '({})'.format(helper.pi_fractions(op.val, r'pi'))
      name += parm
    return name

  # First let's create a matrix according to circuit size,
  # before populating it with gates or lines.
  larr = []
  for q in range(ir.nregs):
    larr.append([''] * (ir.ngates + 1))

  depth = 0
  for op in ir.gates:
    name = mkname(op)
    for r in range(ir.nregs):
      larr[r][depth] = '-' * (len(name) + 2)

    if op.is_single():
      larr[op.idx0][depth] = '-' + name + '-'

    if op.is_ctl():
      larr[op.ctl][depth] = '-' + 'o' + ('-' * (len(name) - 1)) + '-'
      larr[op.idx1][depth] = '-' + name + '-'
      direction = int((op.idx1 - op.ctl) / abs(op.idx1 - op.ctl))
      for i in range(op.ctl + direction, op.idx1, direction):
        larr[i][depth] = '-|-'

    depth += 1

  ret = ''
  for q in range(ir.nregs):
    ret += ''.join(larr[q]) + '\n'

  return ret
